<h1>AutoAnimation List</h1>
<!-- res/anime_api.gif 5 min -->
<h3>How the layzyness equals effectivity</h3>
<p>The classics of the genre; everyone will want to create their own ranking to share with friends at some point. Over time, I grew tired of answering questions like "What's the best anime?" or "What's it about?" and so on. Every self-respecting developer should also demonstrate their ability to use an API. Therefore, I decided to tackle these two issues in one go.</p>
<p>Tech Stack: Flask, SQLAlchemy, Python, Python-requests, WTForms, Bootstrap5.</p>
<h3>Here's a demonstration of how it works:</h3>

<div class="image-container centered-img">
    <img src="static/res/anime_api.webm" alt="Animated gif with autocomplete list based on animation name" >
</div>

<h3>Code components and CRUD demonstration:</h3>
<div class="programmer-container">
    <div class="control-bar">
        <div class="name">main.py</div>
        <div class="buttons">
            <button class="line-numbering-btn disabled" title="Toggle Line Numbers">Line Numbers</button>
            <button class="copy-to-clipboard-btn" title="Copy to Clipboard">Copy to Clipboard</button>
        </div>
    </div>
    <div class="displayer">
        <div class="left-vertical-indicator"></div>
        <div class="code-box">
            

            <pre class="code-box line-numbers code"
    data-prismjs-copy-timeout="500"
    lang="en"
    data-prismjs-copy="Copy"
    data-prismjs-copy-error="Something went wrong"
    data-prismjs-copy-success="Copied to clipboard"
    ><code class="language-python">
 

        @app.route("/")
        def home():
            result = db.session.execute(db.select(Movie).order_by(Movie.rating))
            all_movies = result.scalars().all() #  ScalarResult to Python List
        
            for i in range(len(all_movies)):
                all_movies[i].ranking = len(all_movies) - i
        
            db.session.commit()
        
            return render_template("index.html", movies = all_movies)
        
        @app.route("/add",methods=['GET','POST'])
        def add():
            form = AddForm()
            if form.validate_on_submit():
        
                jikan_api = "https://api.jikan.moe/v4/anime"
        
                params = {
                    'q': form.title.data,
                }
        
                response = requests.get(url=jikan_api,params=params)
                response.raise_for_status()
                data = response.json()
                # Take first result
                # print(data['data'][0])
                our_result = data['data'][0]
                anime_title = our_result['title']
                anime_id = data['data'][0]['mal_id']
                url = data['data'][0]['url']
                main_img = data['data'][0]['images']['jpg']['image_url']
                year_of_release = data['data'][0]['year']
                score = data['data'][0]['score']
                description = data['data'][0]['synopsis']
        
                print(f"Anime id: {anime_id}\nUrl:{url}\nYear of release:{year_of_release}\
                    Score:{score}\n\nDescription:\n{description}")
                
                new_movie = Movie(
                    title=anime_title,
                    year=int(year_of_release),
                    # year=1999,
                    description=description,
                    rating=score,
                    ranking=10,
                    review="",
                    img_url=main_img  
                )
        
                db.session.add(new_movie)
                db.session.commit()
        
                return redirect(url_for('home'))
        
            return render_template('add.html',form=form)
        
        
        @app.route("/edit/<string:id>",methods=['GET','POST'])
        def update(id):
            form = EditForm()
            if request.method == 'POST' and form.validate_on_submit():
                with app.app_context():
                    movie_to_update = db.session.execute(db.select(Movie).where(Movie.id == id)).scalar()
                    movie_to_update.rating = form.rating.data
                    movie_to_update.review = form.review.data
                    db.session.commit() 
                    return redirect(url_for('home'))
            found_movie = db.get_or_404(Movie, id)
        
            return render_template('edit.html',form=form, movie=found_movie)
        
        
        @app.route("/delete/<string:id>",methods=['GET'])
        def delete(id):
            movie_to_delete = db.get_or_404(Movie, id)
            db.session.delete(movie_to_delete)
            db.session.commit()
            return redirect(url_for('home'))
        
        if __name__ == '__main__':
            app.run(debug=True)
        


    </code></pre>

</div>
</div>
</div>


<p>I believe I've managed to create a neat, small project. An almost entirely automatically generated list, yay ðŸ˜¸ To further develop it, you might consider adding "typeHints", share button and idk maybe some advanced account manage?</p>